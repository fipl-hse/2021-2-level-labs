# Лабораторная работа №1

## Дано

1. Три текста на английском, немецком и неизвестном языках
2. Необходимо определить, на каком языке написан последний текст с помощью 
союзов, предлогов, артиклей и других частотных слов, характерных для конкретного языка


## Что надо сделать

### Шаг 0. Подготовка (проделать вместе с преподавателем на практике).

1. Создать форк репозитория
2. Установить необходимые инструменты для работы
3. Изменить файлы `main.py` и `start.py`
4. Закоммитить изменения и создать pull request

**Важно:** в файле `start.py` вы должны написать код, определяющий язык неизвестного текста. 
Для этого реализуйте функции в модуле `main.py` и импортируйте их в `start.py`.
Весь код, выполняющий детектирование языка, должен быть выполнен в блоке `__main__`:

```py
if __name__ == '__main__':
  # your code goes here
  pass
 ```

В рамках данной лабораторной работы **НЕЛЬЗЯ использовать сторонние модули и модуль collections.**


### Шаг 1. Токенизировать текст. 

Функция принимает на вход текст в виде строки.

Функция должна возвращать список слов (токенов) без знаков препинания в нижнем регистре.

Токены могут состоять только из букв английского и немецкого алфавитов (не допускаются цифры и любые другие символы внутри слова).
При этом любые символы (кроме букв) внутри токена удаляются, например, don't заменяется на dont, round-up на roundup и т.д.

Если на вход подаются некорректные значения, возвращается `None`.

Интерфейс: 
```py
def tokenize(text: str) -> list or None:
  pass
```

### Шаг 2. Получить список токенов без стоп-слов.

Функция принимает на вход список токенов и список стоп-слов.

Функция должна возвращать список токенов без стоп-слов. 

Если на вход подаются некорректные токены, возвращается `None`.

Если на вход подаются некорректные стоп-слова, возвращается список токенов без изменений.
Пустой список стоп-слов не считается некорректным значением.


Интерфейс: 
```py
def remove_stop_words(tokens: list, stop_words: list) -> list or None:
  pass
```


### Шаг 3. Получить частотный словарь по заданному тексту.

Функция принимает на вход список токенов.

Функция должна возвращать частотный словарь, где ключ - токен, значение - число (частота).

Если на вход подаются некорректные токены, возвращается `None`.


Интерфейс: 
```py
def calculate_frequencies(tokens: list) -> dict or None:
  pass
```


### Шаг 4. Получить список первых N по популярности слов. Выполнение Шагов 1-4 соответствует 4 баллам

Функция принимает на вход частотный словарь и число топ N слов.

Функция возвращает список первых N по популярности слов.
Первый элемент списка - самое популярное слово. 
Последний элемент списка - N-ное по популярности слово.
Если число N больше числа слов в словаре, 
то возвращаются все слова в порядке убывания их частоты. 

Если на вход подаются некорректные значения, возвращается `None`.

Интерфейс: 
```py
def get_top_n_words(freq_dict: dict, top_n: int) -> list or None:
  pass
```


### Шаг 5. Создать профиль конкретного языка.

Профиль языка – это структура с информацией о конкретном языке.
Подобная простейшая языковая модель часто используется в задаче определения языка.
В настоящей лабораторной работе профиль языка состоит из названия языка, частотного словаря
и количества токенов в данном словаре.

В дальнейших лабораторных работах вы будете работать с другими языковыми профилями.
Пример языковых профилей вы можете найти в следующем проекте (profiles): https://github.com/shuyo/language-detection.
Несмотря на то, что данные профили содержат информацию о n-граммах, 
с которыми мы познакомимся позднее, структура этих профилей аналогична.

Профиль языка представляется следующим образом:
```
{"name": "en",
"freq": {"happy": 2, "the": 1},
"n_words": 2}
```
где ключу `"freq"` соответствует значение – частотный словарь, 
ключу `"n_words"` – количество токенов в словаре,
ключу `"name"` – название языка.

В данной лаборатной работе языковой профиль **обязательно** представляет собой словарь,
который содержит три ключа – `"freq"`, `"n_words"` и `"name"`.

Функция принимает на вход язык в виде строки, текст в виде строки и список стоп-слов.

Функция должна возвращать словарь с вышеназванной структурой. 

Если на вход подаются некорректные значения, возвращается `None`.
Пустой список стоп-слов не считается некорректным значением.

Первоначально текст необходимо токенизировать, стоп-слова необходимо удалить.
Для этого необходимо использовать функции `tokenize` и `remove_stop_words`.

Для получения частотного словаря необходимо использовать функцию `calculate_frequencies`.

Интерфейс: 
```py
def create_language_profile(language: str, text: str, stop_words: list) -> dict or None:
  pass
```


### Шаг 6. Найти пересечение между N частотных слов на разных языках

Найти долю пересекающихся частотных слов в текстах на разных языках.

Для этого необходимо разделить количество общих токенов на длину списка токенов на неизвестном языке.
Например, если топ N слов для английского языка – `['a', 'an', 'the', 'by']`, 
а для неизвестного – `['an', 'the', 'with', 'is']`. Количество общих токенов – `2` (`['an', 'the']`), 
длина списка токенов на неизвестном языке – `4`. Тогда доля пересекающихся частотных слов равна `2 / 4 = 0.5`.

Функция принимает на вход два языковых профиля и число топ N слов.

Функция должна возвращать объект типа `float`. 

Если на вход подаются некорректные значения, возвращается `None`.

Для получения топ N слов необходимо использовать функцию `get_top_n_words`.

Интерфейс: 
```py
def calculate_distance(profile_1: dict, profile_2: dict, top_n: int) -> float or None:
  pass
```

### Шаг 7. Определить язык неизвестного текста. Выполнение Шагов 1-7 соответствует 6 баллам


Функция принимает на вход языковой профиль на неизвестном языке и два языковых профиля на известных.

Функция определяет язык текста на основе доли пересекающихся частотных слов.
Функция возвращает название языка с наибольшей долей пересекающихся частотных слов. 
Название языка находится в языковом профиле.

Если на вход подаются некорректные значения, возвращается `None`.

Для нахождения доли пересекающихся частотных слов необходимо использовать функцию `calculate_distance`.

Интерфейс: 
```py
def detect_language(unknown_profile: dict, profile_1: dict, profile_2: dict) -> str or None:
  pass
```


### Шаг 8. Определить язык неизвестного текста (усложнение).

Вы должны понимать, что для определения языка может быть недостаточно двух языковых профилей.
На самом деле в данной задаче может использоваться произвольное количество языковых профилей (например, 30).

С другой стороны, большое количество профилей может привести к значительному увеличению времени детектирования.
Одним из способов решения данной проблемы является ограничение списка возможных языков.
Для этого в детектор передается список возможных языков, например `['en', 'de']`, 
и тогда для определения языка используются только профили конкретных языков (что уменьшает временные затраты).

На данном шаге вам нужно расширить функционал уже построенного детектора, 
добавив возможность работы с произвольным количеством профилей и возможность ограничивать список возможных языков.

Функция принимает на вход языковой профиль на неизвестном языке, список языковых профилей на известных
и список возможных языков.

Если список возможных языков пуст, определение языка производится на основе **всех доступных языковых профилей**.
Если список содержит какие-либо языки, 
определение языка производится только на основе **профилей конкретных языков**.

Функция определяет язык текста на основе доли пересекающихся частотных слов.
Функция возвращает название языка с наибольшей долей пересекающихся частотных слов. Название языка находится в языковом профиле.

Если на вход подаются некорректные значения, возвращается `None`.

Для нахождения доли пересекающихся частотных слов необходимо использовать функцию `calculate_distance`.

Интерфейс: 
```py
def detect_language_advanced(unknown_profile: dict, profiles: list, languages: list) -> str or None:
  pass
```

### Шаг 9. Получить отчет по языкам. Выполнение Шагов 1-9 соответствует 8 баллам


Функция принимает на вход языковой профиль на неизвестном языке и языковые профили на известных.

Функция возвращает список коэффициентов для каждого языка, посчитанных на основе пересекающихся частотных слов.

Отчет представляет собой список из словарей вида
```
[{"name": "en", "score": "0.2"},
 {"name": "de", "score": "0.1"}]
```

Если на вход подаются некорректные значения, возвращается `None`.

Для получения коэффициентов необходимо использовать функцию `calculate_distance`.

Интерфейс: 
```py
def create_report(unknown_profile: dict, profiles: list, languages: list) -> list or None:
  pass
```


### Шаг 10. Работа с файлами. Выполнение Шагов 1-10 соответствует 10 баллам

В рамках модуля `start.py` вы работаете с маленькими текстами. 
Но представьте, что вам нужно обработать огромный корпус текстов и получить по ним языковой профиль.
Сколько времени занимает данная обработка? 
Хотели ли бы вы её выполнять каждый раз при определении языка неизвестного текста?

Созданный языковой профиль необходимо сохранять в файл для дальнейшего использования.
В последующие разы языковой профиль необходимо загружать из уже созданного ранее файла.

Функция `load_profile` принимает на вход путь к файлу с расширением `.json` с языковым профилем.
Содержимое данного файла представляет собой словарь вида:
```
{"name": "en",
"freq": {"happy": 2, "the": 1},
"n_words": 2}
```
где ключу `"freq"` соответствует значение – частотный словарь, 
ключу `"n_words"` – количество токенов в словаре,
ключу `"name"` – название языка.

Функция `load_profile` должна возвращать словарь.

Если на вход подаются некорректные значения, возвращается `None`.

Функция `save_profile` принимает на вход языковой профиль и 
записывает его в файл с расширением `.json` в вышеназванном формате. 
Название файла - `*.json`, где `*` – это название языка. Файл должен лежать в папке `'lab_1'`.

Функция `save_profile` возвращает `0`, если запись в файл прошла успешно.

Если на вход подаются некорректные значения, возвращается `1`.

Для записи и загрузки языкового профиля **необходимо использовать библиотеку `json`.**

В `start.py` вам необходимо продемонстрировать определение языка при помощи внешних языковых профилей, 
которые вы найдете в папке `'lab_1'`.
Сравните результаты определения языка на основе ваших и внешних (загруженных) языковых профилей.

Интерфейс: 
```py
def load_profile(path_to_file: str) -> dict or None:
  pass
```

```py
def save_profile(profile: dict) -> int:
  pass
```
