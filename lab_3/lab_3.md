# Лабораторная работа №3

Данная лабораторная работа предполагает расширение полученных 
знаний детектирования (классификации) неизвестного текста.
Для этого будет использоваться новый способ представления текста в виде N-грамм.

## Дано

1. Три текста на английском, немецком и неизвестном языках.
2. Необходимо определить, на каком языке написан последний текст.

**_Важно:_** в файле `start.py` вы должны написать код, определяющий язык неизвестного текста. 
Для этого реализуйте функции в модуле `main.py` и импортируйте их в `start.py`.
Весь код, выполняющий детектирование языка, должен быть выполнен в блоке `__main__:`.

В рамках данной лабораторной работы **НЕЛЬЗЯ использовать сторонние модули и модуль collections.**

## Терминология

В рамках данной работы вы будете работать с N-граммами.

N-грамма - это последовательность из n элементов, в настоящей работе - 
последовательность из n букв.

Один элемент - униграмма.

Последовательность из двух элементов - биграмма.

Последовательность из трех элементов - триграмма.

Последовательность из четырех и более элементов обозначается как N-грамма,
где N заменяется на количество последовательных элементов.

Например, `word = 'sunny'`, `unigrams = ['s', 'u', 'n', 'n', 'y']`,
`bigrams = ['su', 'un', 'nn', 'ny']`, `trigrams = ['sun', 'unn', 'nny']`.

**_Важно:_** вам необходимо уметь собирать следующие N-граммы на определенные оценки:

- 6 - биграммы
- 8 - триграммы
- 10 - N-граммы

## Ход работы

В рамках лабораторной работы №3 требуется разобрать алгоритм извлечения
N-гармм из текста и использовать их для определения языка произвольного текста.

### Шаг 1. Разбить исходный текст на предложения и токены

Функция разбивает заданный текст на предложения и возвращает кортеж
предложений с токенами.

В качестве разделителя используется завершающий пунктуационный знак, пробел
и факт того, что следующее слово начинается с большой буквы.

Каждое предложение токенизируется и разбивается по буквам. Все строки (буквы)
в нижнем регистре, не содержат знаков пунктуации, в том числе и завершающий
знак препинания.

Каждый токен (например, `she` в примере ниже) также содержит специальные
символы начала (`_`) и конца слова (`_`). Вставка этих символов 
обязательна для корректной работы алгоритма в дальнейшем. 

В немецком тексте буквы с умлаутами ö, ü, ä должны быть заменены на
oe, ue, ae; ß заменено на ss.

Если на вход подаются некорректные значения, возвращается пустой список.

Например,
```py
input_text = 'She is happy. He is happy.' 

output_text = (
         (('_', 's', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_')),
         (('_', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_'))
)
```

**Интерфейс**:
```py
def tokenize_by_sentence(text: str) -> tuple:
    pass
```

### Шаг 2. Создание хранилища соответствий буква-число

Каждой букве из заданного текста присваивается некоторый уникальный идентификатор
`id`. Это требуется для того, чтобы работать не со строками напрямую, а с числами,
которые их представляют.

Например, букве `'a'` ставим в соответствие некоторое уникальное 
число - `12345`. Следующей букве `'c'` - `12346` и так далее.
Эти буквы необходимо поместить в поле `storage` класса `LetterStorage`,
ключом хранилища является буква, а значением – её идентификатор.
Буквы, указанные выше, будут храниться следующим образом:

```py
self.storage = {..., 'a': 12345, 'c': 12346, ...}
```

Для хранения букв и их идентификаторов необходимо создать поле класса - `storage`.  

**Интерфейс**:

```py
class LetterStorage:
    pass
```

### Шаг 2.1. Добавление буквы в хранилище

Метод принимает на вход букву и добавляет её в хранилище `storage`.

Выбор правила для присваивания 
идентификатора (счетчик, начинающийся с нуля или с заданного значения) - произвольный - на ваш
выбор. Основное условие - для одной и той же буквы существует ровно один идентификатор.
Одинаковых идентификаторов у двух разных букв быть не может.

Если буква была добавлена в хранилище или уже существовала в нем, возвращается `0`.
При этом если буква уже существовала в хранилище, идентификатор остается прежним.

Если на вход подается некорректное значение, возвращается `-1`.
Пустая строка считается **некорректным** значением.

**Интерфейс**:

```py
class LetterStorage:
  ...
  def _put_letter(self, letter: str) -> int:
    pass
```

### Шаг 2.2. Получения идентификатора буквы

Метод принимает на вход букву и возвращает её идентификатор.

Если на вход подается неизвестная буква, возвращается `-1`.

**Интерфейс**:

```py
class LetterStorage:
  ...
  def get_id_by_letter(self, letter: str) -> int:
    pass
```

### Шаг 2.3. Получения буквы по идентификатору

Метод принимает на вход идентификатор и возвращает соответствующую букву.

Если на вход подается неизвестный или некорректный идентификатор, возвращается `-1`.

**Интерфейс**:

```py
class LetterStorage:
  ...
  def get_letter_by_id(self, letter_id: int) ->str or int:
    pass
```

### Шаг 2.4. Заполнение хранилища буквами из корпуса предложений

Метод заполняет хранилище-словарь `self.storage` 
класса `LetterStorage` буквами из кортежа предложений.

Например,
```py
corpus = (
         (('_', 's', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_')),
         (('_', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_'))
         )
```

Если добавление прошло успешно, возвращается `0`.
Если на вход подается некорректное значение, возвращается `-1`.

**Дополнительные требования:**

1. В данной функции ОБЯЗАТЕЛЬНО использовать метод `_put_letter`.

**Интерфейс**:

```py
class LetterStorage:
  ...
  def update(self, corpus: tuple) -> int:
    pass
```

### Шаг 3. Кодирование корпуса предложений

Функция кодирует корпус предложений, используя заполненный экземпляр 
класса `LetterStorage`, и возвращает кортеж закодированных предложений.
Кодирование заключается в замене букв на соответствующие идентификаторы.

Например для заданного корпуса, 
```py
input_corpus = (
         (('_', 's', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_')),
         (('_', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_'))
         )
```
Будет получен следующий закодированный корпус:
```py
encoded_corpus = (
                  ((1, 2, 3, 4, 1), (1, 5, 2, 1), (1, 3, 6, 7, 7, 8, 1)),
                  ((1, 3, 4, 1), (1, 5, 2, 1), (1, 3, 6, 7, 7, 8, 1))
                  )
```

Если на вход подаются некорректные значения, возвращается пустой кортеж.

**Дополнительные требования:**

1. В данной функции ОБЯЗАТЕЛЬНО использовать метод `get_id_by_letter`.

**Интерфейс**:

```py
def encode_corpus(storage: LetterStorage, corpus: tuple) -> tuple:
  pass
```

### Шаг 4. Декодирование корпуса предложений (Выполнение шагов 1-4 соответствует 4 баллам)

Функция декодирует корпус предложений, используя заполненный экземпляр класса `LetterStorage`,
и возвращает кортеж исходных предложений.
Декодирование заключается в замене идентификаторов на соответствующие буквы.
Работа данной функции противоположна работе функции `encode_corpus`.

Например для заданного закодированного текста, 
```py
input_corpus = (
  ((1, 2, 3, 4, 1), (1, 5, 2, 1), (1, 3, 6, 7, 7, 8, 1)),
  ((1, 3, 4, 1), (1, 5, 2, 1), (1, 3, 6, 7, 7, 8, 1))
)
```
Будет получен следующий декодированный текст:
```py
decoded_corpus = (
  (('_', 's', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_')),
  (('_', 'h', 'e', '_'), ('_', 'i', 's', '_'), ('_', 'h', 'a', 'p', 'p', 'y', '_'))
)
```

Если на вход подаются некорректные значения, возвращается пустой кортеж.

**Дополнительные требования:**

1. В данной функции ОБЯЗАТЕЛЬНО использовать метод `get_letter_by_id`.

**Интерфейс**:

```py
def decode_corpus(storage: LetterStorage, corpus: tuple) -> tuple:
  pass
```

### Шаг 5. Создать структуру для хранения и обработки N-грамм

Класс `NGramTrie` позволяет собрать N-граммы из 
заданного закодированного предложения или текста.

> Это не опечатка в названии класса. 
> Такое название выбрано намеренно (trie является отраслевым термином).

Допустим, закодированный текст выглядит следующим образом: 
`text = (((1, 2, 3, 1), (1, 4, 5, 1), (1, 2, 6, 7, 7, 8, 1)),)`

1. Например, если нам необходимо заполнить NGramTrie с n, равным 2,
то мы получим следующие биграммы:
`((((1, 2), (2, 3), (3, 1)), ((1, 4), (4, 5), (5, 1)), ((1, 2), (2, 6), (6, 7), (7, 7), (7, 8), (8, 1))),)`

2. Например, если нам необходимо заполнить NGramTrie с n, равным 3,
то мы получим следующие триграммы:
`((((1, 2, 3), (2, 3, 1)), ((1, 4, 5), (4, 5, 1)), ((1, 2, 6), (2, 6, 7), (6, 7, 7), (7, 7, 8), (7, 8, 1))),)`

### Шаг 5.1. Объявить сущность языковой модели

Создадим класс:

```py
class NGramTrie:
    pass
```

Конструктор принимает на вход размер N-граммы `n`. Это значение
сохраняется в собственном поле экземпляра класса - `self.size`. 

Конструктор также принимает экземпляр класса хранилища `LetterStorage`.
Это значение сохраняется в собственном поле экземпляра класса - `self.storage`.

Сами N–граммы хранятся (после расчета) в поле экземпляра класса – `self.n_grams`.

Также, в конструкторе присутствует поле `self.n_gram_frequencies`,
в котором хранятся N-граммы и их частоты в виде словаря.

Например, при инициализации класса `NGramTrie` c хранилищем букв и размером N-грамм равным 2,
конструктор будет выглядеть следующим образом:
```py
ngrams = NGramTrie(letter_storage_object, 2)
print(ngrams.size) # 2
print(ngrams.storage) # LetterStorage class instance
print(ngrams.ngrams) # []
print(ngrams.n_gram_frequencies) # {}
```

### Шаг 5.2. Извлечь N-граммы из закодированного корпуса

Метод принимает на вход закодированный корпус, извлекает N-граммы
(размер N-грамм хранится в поле `self.size`) и заполняет поле `self.n_grams`.

> Для студентов, желающих получить оценку 6, на данном этапе 
> достаточно реализовать только биграммы.

Если добавление прошло успешно, возвращается `0`.
Если на вход подается некорректное значение, возвращается `1`.

Например, для заданного текста, при работе с биграммами:
```py
input_text = (((1, 2, 3, 1), (1, 4, 5, 1), (1, 2, 6, 7, 7, 8, 1)),)
```
Метод заполнит поле `self.ngrams` следующими биграмами:
```py
print(self.ngrams) # ((((1, 2), (2, 3), (3, 1)), ((1, 4), (4, 5), (5, 1)), ((1, 2), (2, 6), (6, 7), (7, 7), (7, 8), (8, 1))),)
```

**Интерфейс**:
```py
class NGramTrie:
  ...
  def extract_n_grams(self, encoded_corpus: tuple) -> int:
      pass
```

### Шаг 5.3. Получить самые частотные N-граммы

Метод получает частотные N-граммы используя поле `self.n_grams`.
Метод заполняет поле `self.n_gram_frequencies`.

Если добавление прошло успешно, возвращается 0.
Если на вход подается некорректное значение, возвращается 1.

Например, при следующих N-граммах в поле `self.ngrams`:
```py
print(self.ngrams) # ((((1, 2), (2, 3), (3, 1)), ((1, 4), (4, 5), (5, 1)), ((1, 2), (2, 6), (6, 7), (7, 7), (7, 8), (8, 1))),)
```
По результатам вызова текущего метода будет заполнено
поле `self.n_gram_frequencies` следующим образом:
```py
print(self.n_gram_frequencies) # {(1, 2): 2, (2, 3): 1, (3, 1): 1, (1, 4): 1, (4, 5): 1, (5, 1): 1, (2, 6): 1, (6, 7): 1, (7, 7): 1, (7, 8): 1, (8, 1): 1}
```

**Интерфейс**:
```py
class NGramTrie:
  ...
  def get_n_grams_frequencies(self) -> int:
      pass
```

### Шаг 6. Создать структуру для представления языкового профиля

Создадим класс:

```py
class LanguageProfile:
    pass
```

Конструктор принимает на вход экземпляр класса хранилища `LetterStorage`. 
Это значение сохраняется в собственном поле экземпляра класса - `self.storage`.

Конструктор также принимает на вход метку языка, для которого будет создаваться
языковой профиль `language_name`. Это значение сохраняется в собственном поле 
экземпляра класса `self.language`.

Помимо заполняемых при инициализации класса полей, у класса `LanguageProfile`
также присутствуют поля, которые будут заполнены при дальнейшей работе с классом:

- `self.tries` - список из объектов класса `NGramTrie`, в которых хранятся N-граммы
    для языкового профиля
- `self.n_words` - список количества каждого вида N-грамм, участвующих в построении
    языкового профиля
    
Например, при инициализации класса `LanguageProfile` c хранилищем букв и меткой языка `en`,
конструктор будет выглядеть следующим образом:
```py
en_profile = LanguageProfile(letter_storage_object, 'en')
print(en_profile.storage) # LetterStorage class instance
print(en_profile.language) # `en`
print(en_profile.tries) # []
print(en_profile.n_words) # []
```

### Шаг 6.1. Заполнить языковой профиль

Метод принимает на вход закодированный текст `encoded_corpus`, 
а также кортеж с размерностями N-грамм `ngram_sizes`.

Метод создает языковой профиль. 
Для каждой размерности N-граммы из кортежа `ngram_sizes`
создается и заполняется N-граммами экземпляр класса `NGramTrie`,
а затем этот экземпляр помещается в соответствующее поле класса `self.tries`.

Также, для каждой размерности N-граммы из кортежа `ngram_sizes`
также считается число N-грамм этой размерности (сумма) и
помещается в поле класса `self.n_words`.

Например, для заданного закодированного корпуса:
```py
encoded_corpus = (((1, 2, 3, 1), (1, 4, 5, 1), (1, 2, 6, 7, 7, 8, 1)),)
```
Поля `self.tries` и `self.n_words` заполнятся следующим образом:
```py
print(self.tries) # [<__main__.NGramTrie object at 0x09DB9BB0>, <__main__.NGramTrie object at 0x09DB9A48>]
print(self.n_words) # [11, 9]
```

**Обратите внимание**, что поле `self.tries` хранит именно экземпляры класса `NGramTrie` и
мы можем получить желаемые биграммы или триграммы, обратившись к
соответствующему экземпляру класса `NGramTrie` из списка `self.tries`:
```py
print(self.tries[0].n_grams) # ((((1, 2), (2, 3), (3, 1)), ((1, 4), (4, 5), (5, 1)), ((1, 2), (2, 6), (6, 7), (7, 7), (7, 8), (8, 1))),)
```
 
Метод возвращает `0`, если заполнение обозначенных полей прошло успешно
и возвращает `1` в противном случае.

**Интерфейс**:
```py
class LanguageProfile:
  ...
  def create_from_tokens(self, encoded_corpus: tuple, ngram_sizes: tuple) -> int:
      pass
```

### Шаг 6.2. Получить топ k самых частотных N-грамм

Метод получает на вход параметр `k` - число самых частотных N-грамм.

Метод также получает параметр `trie_level` - размерность N-граммы,
например, 2 - биграммы, 3 - триграммы.

Метод возвращает кортеж из `k` самых частотных N-грамм.

Например, для заданного закодированного текста и существующего профиля
с `self.tries` с 2-3-граммами. При параметре `k` = 3 и параметре `trie_level` = 2, а затем 3:
```py
encoded_corpus = (((1, 2, 3, 1), (1, 4, 5, 1), (1, 2, 6, 7, 7, 8, 1)),)
print(self.tries) # [<__main__.NGramTrie object at 0x09DB9BB0>, <__main__.NGramTrie object at 0x09DB9A48>]
```
Будут получены следующие 3 самых частотных 2-3-граммы соответственно:
```py
print(top_3_bi_grams) # ((1, 2), (2, 3), (3, 1))
print(top_3_three_grams) # ((1, 2, 3), (2, 3, 1), (1, 4, 5))
```

Если на вход подается некорректное значение, возвращается пустой кортеж.

**Интерфейс**:
```py
class LanguageProfile:
  ...
  def get_top_k_n_grams(self, k: int, trie_level: int) -> tuple:
      pass
```

### Шаг 6.3. Подсчитать расстояние между двумя языковыми профилями (Выполнение шагов 5-6.3 соответствует 6 баллам)

Функция принимает на вход неизвестный и известный языковые профили, а также
параметр `k` - кол-во частотных N-грамм и `trie_level` - тип N-грамм (биграмма, триграмма и т.д.).

Функция получает наборы частотных N-грамм из языковых профилей.
Функция сравнивает наборы частотных N-грамм у двух языковых профилей.

Правило подсчёта расстояния:
* Для каждой N-граммы из первого кортежа находится соответствующая N-грамма
  во втором кортеже.
* Расстояние между ними рассчитывается как модуль разности индексов.
* Если N-грамма отсутствует во втором кортеже, расстояние равняется длине второго кортежа.
* Все полученные расстояния суммируются.

Например, первый набор частотных N-грамм - `first_n_grams = ((1, 2), (4, 5), (2, 3))`,
второй набор – `second_n_grams = ((1, 2), (2, 3), (4, 5))`. Расстояние для `(1, 2)` равно `0`,
так как индекс в первом наборе – `0`, во втором – `0`, `|0 – 0| = 0`. Расстояние для `(4, 5)` равно `1`,
расстояние для `(2, 3)` равно `1`. Соответственно расстояние между наборами равно `2`.

Если на вход подаются некорректные значения, возвращается -1.

**Интерфейс**:
```py
def calculate_distance(unknown_profile: LanguageProfile, 
                       known_profile: LanguageProfile, 
                       k: int, trie_level: int) -> tuple:
    pass
```
